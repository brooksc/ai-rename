#!/usr/bin/env python3
import argparse
import json
import logging
import os
import re
import shutil
import subprocess
import sys

import progressbar
import requests


# import openai  # Assuming you have the openai library installed
# import progressbar


# Function to perform OCR on the file
def perform_ocr(file_path, LANGUAGE):
    ocr_text = ""
    if file_path.lower().endswith('.pdf'):
        # Convert PDF to PNG for OCR processing
        image_file = f"{os.path.splitext(file_path)[0]}.png"
        subprocess.run(['pdftoppm', file_path, os.path.splitext(file_path)[0], '-png', '-f', '1', '-singlefile'])
        if os.path.isfile(image_file):
            ocr_text = subprocess.check_output(['tesseract', image_file, '-', '-l', LANGUAGE]).decode('utf-8')
            os.remove(image_file)
    elif file_path.lower().endswith(('.jpg', '.png')):
        ocr_text = subprocess.check_output(['tesseract', file_path, '-', '-l', LANGUAGE]).decode('utf-8')
    return ocr_text.strip()


# Function to generate a filename based on OCR content using AI
def generate_filename(ocr_text):
    filename_prompt = config['prompts']['filename_generation']
    payload = {"messages": [{"role": "system", "content": filename_prompt},
                            {"role": "user", "content": f"Here is the file content: {ocr_text}"}],
               "temperature": 0, "max_tokens": -1, "stream": False}

    response = requests.post('http://localhost:11434/v1/chat/completions', headers={"Content-Type": "application/json"},
                             data=json.dumps(payload))
    if response.status_code == 200:
        response_json = response.json()
        filename = response_json['choices'][0]['message']['content']
        return filename.strip()
    return None


# Function to clean and validate the generated filename
def clean_filename(filename):
    cleaned_content = re.sub(r'[^a-zA-Z0-9 ]', ' ', filename)
    cleaned_content = re.sub(r'\s+', ' ', cleaned_content).strip()
    cleaned_content = re.sub(r'([a-z])([A-Z])', r'\1 \2', cleaned_content)
    content_length = len(cleaned_content)

    if 15 <= content_length <= 100:
        return cleaned_content
    return None


def rename_pdf(file_path, file_name, DONE_DIR, ORIG_DIR, KEEP_ORIGINAL, new_filename):
    new_filepath = os.path.join(DONE_DIR, new_filename)

    if args.move:
        shutil.move(file_path, new_filepath)
        print(f"'{file_path}' was successfully renamed to '{new_filepath}' and moved")
    elif KEEP_ORIGINAL:
        shutil.copy2(file_path, new_filepath)
        shutil.move(file_path, os.path.join(ORIG_DIR, file_name))
        print(f"'{file_path}' was successfully renamed to '{new_filepath}' and copied")
    else:
        os.rename(file_path, new_filepath)
        print(f"'{file_path}' was successfully renamed to '{new_filepath}'")


def read_config():
    config_file = 'config.json'
    if os.path.exists(config_file):
        with open(config_file, 'r') as f:
            return json.load(f)
    return {}


def write_config(config):
    config_file = 'config.json'
    with open(config_file, 'w') as f:
        json.dump(config, f, indent=4)


# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Initialize argument parser
parser = argparse.ArgumentParser(description='Process files in a directory using OCR and AI to generate filenames.')
parser.add_argument('directory', type=str, help='The directory containing files to process.')
parser.add_argument('-s', '--summarize', action='store_true', help='Enable summarization of the OCR text.')
parser.add_argument('-m', '--move', action='store_true', help='Move the files after processing.')
parser.add_argument('-o', '--keep-ocr-output', action='store_true',
                    help='Keep a copy of the OCR output per file in the same directory.')
parser.add_argument('-d', '--debug', action='store_true', help='Enable debug logging.')
parser.add_argument('--keep-original', type=bool, default=True,
                    help='Preserve the original file after renaming. Default is True.')

args = parser.parse_args()

# Configure logging based on debug flag
if args.debug:
    logging.getLogger().setLevel(logging.DEBUG)

DIR = args.directory
KEEP_ORIGINAL = args.keep_original

# Check if the provided argument is a valid directory
if not os.path.isdir(DIR):
    create_dir = input(f"The directory '{DIR}' does not exist. Do you want to create it? (y/n): ")
    if create_dir.lower() == 'y':
        os.makedirs(DIR)
        logging.info(f"Directory '{DIR}' created.")
    else:
        logging.error(f"The directory '{DIR}' does not exist.")
        sys.exit(1)

# Read the configuration file
config = read_config()
LANGUAGE = config.get('LANGUAGE', 'eng')
ORIG_SUBDIR = config.get('ORIG_SUBDIR', "orig")

# If the configuration file does not exist, prompt the user to enter the settings
if not config:
    LANGUAGE = input(f"Enter the language for OCR (default: {LANGUAGE}): ") or LANGUAGE
    ORIG_SUBDIR = input(f"Enter the original subdirectory (default: {ORIG_SUBDIR}): ") or ORIG_SUBDIR
    write_config({'LANGUAGE': LANGUAGE, 'ORIG_SUBDIR': ORIG_SUBDIR})

# Create a 'done' directory within the provided directory to store processed files
DONE_DIR = os.path.join(DIR, 'done')
os.makedirs(DONE_DIR, exist_ok=True)
ORIG_DIR = os.path.join(DIR, ORIG_SUBDIR)
os.makedirs(ORIG_DIR, exist_ok=True)

# Lookup table for file extensions to their respective processing functions
extension_to_function = {# '.pdf': rename_pdf
}

# Process each file in the directory
for file_name in os.listdir(DIR):
    file_path = os.path.join(DIR, file_name)
    file_extension = os.path.splitext(file_name)[1].lower()

    if os.path.isfile(file_path) and file_extension in extension_to_function:
        extension_to_function[file_extension](file_path, file_name, DONE_DIR, ORIG_DIR, KEEP_ORIGINAL, LANGUAGE)

# Lookup table for file extensions to their respective processing functions
extension_to_function = {# '.pdf': rename_pdf
}

# Process each file in the directory
for file_name in os.listdir(DIR):
    file_path = os.path.join(DIR, file_name)
    file_extension = os.path.splitext(file_name)[1].lower()

    if os.path.isfile(file_path) and file_extension in extension_to_function:
        extension_to_function[file_extension](file_path, file_name, DONE_DIR, ORIG_DIR, KEEP_ORIGINAL, LANGUAGE)

if not args.debug:
    # Initialize progress bar
    total_files = sum(1 for file_name in os.listdir(DIR) if
                      os.path.isfile(os.path.join(DIR, file_name)) and file_name.lower().endswith(
                          ('.pdf', '.jpg', '.png')))
    bar = progressbar.ProgressBar(maxval=total_files,
                                  widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])
    bar.start()

file_count = 0

# Process each file in the directory
for file_name in os.listdir(DIR):
    file_path = os.path.join(DIR, file_name)

    if os.path.isfile(file_path) and file_path.lower().endswith(('.pdf', '.jpg', '.png')):
        print(f"{file_path}")

        print("Starting OCR recognition ...")
        ocr_text = perform_ocr(file_path, LANGUAGE)
        if args.keep_ocr_output:
            ocr_output_filename = f"{os.path.splitext(file_name)[0]}_ocr_output.txt"
            ocr_output_filepath = os.path.join(DONE_DIR, ocr_output_filename)
            with open(ocr_output_filepath, 'w') as f:
                f.write(ocr_text)
            print(f"OCR output saved to '{ocr_output_filepath}'")

        if ocr_text:
            print("OCR successful")
            print("Starting AI request ...")

            ai_generated_filename = generate_filename(ocr_text)
            if ai_generated_filename:
                cleaned_filename = clean_filename(ai_generated_filename)
                if cleaned_filename:
                    file_extension = os.path.splitext(file_name)[1]
                    new_filename = f"{cleaned_filename}{file_extension}"
                    new_filepath = os.path.join(DONE_DIR, new_filename)

                    if args.move:
                        shutil.move(file_path, new_filepath)
                        print(f"'{file_path}' was successfully renamed to '{new_filepath}' and moved")
                    elif KEEP_ORIGINAL:
                        shutil.copy2(file_path, new_filepath)
                        shutil.move(file_path, os.path.join(ORIG_DIR, file_name))
                        print(f"'{file_path}' was successfully renamed to '{new_filepath}' and copied")

                    # Generate summary
                    if args.summarize:
                        # Use LLM for summarization
                        summarization_prompt = config['prompts']['summarization']
                        response = requests.post('http://localhost:11434/api/generate', json={"model": "llama3.1",
                            "prompt": summarization_prompt, "max_tokens": 100})
                        if response.status_code == 200:
                            try:
                                summary_data = response.json()
                                summary = summary_data.get('response', '').strip()
                            except requests.exceptions.JSONDecodeError:
                                summary = None
                        else:
                            summary = None
                        if summary:
                            summary_filename = f"{cleaned_filename}_summary.txt"
                            summary_filepath = os.path.join(DONE_DIR, summary_filename)
                            with open(summary_filepath, 'w') as f:
                                f.write(summary)
                            print(f"Summary saved to '{summary_filepath}'")
                        else:
                            print("Failed to generate summary.")
                else:
                    print("Resulting filename is not between 15 - 100 characters")
            else:
                print("No valid filename could be extracted from the AI response.")
        else:
            print(f"OCR processing of '{file_path}' failed or no text recognized.")

        if not args.debug:
            file_count += 1
            bar.update(file_count)

    if not args.debug:
        bar.finish()
