#!/usr/bin/env python3

import os
import sys
import json
import shutil
import logging
import argparse
import subprocess
import progressbar
import requests
import re
from typing import Dict, Any
from pathlib import Path

def handle_exception(operation: str, exception: Exception) -> None:
    if isinstance(exception, FileNotFoundError):
        logging.error(f"File not found during {operation}: {str(exception)}")
    elif isinstance(exception, PermissionError):
        logging.error(f"Permission denied during {operation}: {str(exception)}")
    elif isinstance(exception, IOError):
        logging.error(f"I/O error occurred during {operation}: {str(exception)}")
    elif isinstance(exception, subprocess.CalledProcessError):
        logging.error(f"Subprocess error during {operation}: {str(exception)}")
    elif isinstance(exception, requests.RequestException):
        logging.error(f"Network error during {operation}: {str(exception)}")
    elif isinstance(exception, json.JSONDecodeError):
        logging.error(f"JSON decoding error during {operation}: {str(exception)}")
    else:
        logging.error(f"Unexpected error during {operation}: {str(exception)}")

class FileProcessor:
    def __init__(self, config: Dict[str, Any], args: argparse.Namespace):
        self.config = config
        self.args = args
        self.extension_to_function = {'.pdf': self.rename_pdf}

    def setup_directories(self, base_dir: str) -> Dict[str, str]:
        done_dir = os.path.join(base_dir, 'done')
        orig_dir = os.path.join(base_dir, self.config.get('ORIG_SUBDIR', 'orig'))
        self.create_directory(done_dir)
        self.create_directory(orig_dir)
        return {'DONE_DIR': done_dir, 'ORIG_DIR': orig_dir}

    def create_directory(self, dir_path: str) -> None:
        try:
            os.makedirs(dir_path, exist_ok=True)
            logging.info(f"Directory '{dir_path}' created.")
        except Exception as e:
            handle_exception("directory creation", e)
            sys.exit(1)

    def process_files(self, dir_path: str) -> None:
        dirs = self.setup_directories(dir_path)
        total_files = self.count_files(dir_path)

        if not self.args.debug and total_files > 0:
            bar = self.setup_progress_bar(total_files)
        else:
            bar = None

        for file_count, file_name in enumerate(os.listdir(dir_path)):
            self.process_single_file(dir_path, file_name, dirs, file_count, bar)

        if bar:
            bar.finish()

    def count_files(self, dir_path: str) -> int:
        return sum(1 for file_name in os.listdir(dir_path)
                   if os.path.isfile(os.path.join(dir_path, file_name))
                   and file_name.lower().endswith(('.pdf', '.jpg', '.png')))

    def setup_progress_bar(self, total_files: int) -> progressbar.ProgressBar:
        return progressbar.ProgressBar(maxval=total_files,
                                       widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])

    def process_single_file(self, dir_path: str, file_name: str, dirs: Dict[str, str],
                            file_count: int, bar: progressbar.ProgressBar) -> None:
        file_path = os.path.join(dir_path, file_name)
        file_extension = os.path.splitext(file_name)[1].lower()

        if os.path.isfile(file_path) and file_extension in self.extension_to_function:
            self.process_file(file_path, file_name, self.extension_to_function[file_extension], dirs)

        if bar:
            bar.update(file_count + 1)

    def process_file(self, file_path: str, file_name: str, process_func: callable, dirs: Dict[str, str]) -> None:
        if self.args.debug:
            logging.debug(f"Processing file: {file_path}")

        try:
            process_func(file_path, file_name, dirs['DONE_DIR'], dirs['ORIG_DIR'])
        except Exception as e:
            handle_exception("file processing", e)

        if self.args.summarize:
            try:
                self.generate_summary(file_path, file_name, dirs['DONE_DIR'])
            except Exception as e:
                handle_exception("summary generation", e)

    def generate_summary(self, file_path: str, file_name: str, done_dir: str) -> None:
        try:
            ocr_text = self.perform_ocr(file_path)
            summarization_prompt = f"{self.config['prompts']['summarization']}:{ocr_text}"
            summary = self.call_llm(summarization_prompt)
            if summary:
                self.save_summary(file_name, summary, done_dir)
            else:
                logging.warning(f"Failed to generate summary for {file_path}")
        except Exception as e:
            logging.error(f"Error generating summary for {file_path}: {str(e)}")

    def save_summary(self, file_name: str, summary: str, done_dir: str) -> None:
        summary_filename = f"{os.path.splitext(file_name)[0]}_summary.txt"
        summary_filepath = os.path.join(done_dir, summary_filename)
        with open(summary_filepath, 'w') as f:
            f.write(summary)
        logging.info(f"Summary saved to '{summary_filepath}'")

    def perform_ocr(self, file_path: str) -> str:
        ocr_text = ""
        if file_path.lower().endswith('.pdf'):
            ocr_text = self.perform_pdf_ocr(file_path)
        elif file_path.lower().endswith(('.jpg', '.png')):
            ocr_text = self.perform_image_ocr(file_path)
        return ocr_text.strip()

    def perform_pdf_ocr(self, file_path: str) -> str:
        image_file = f"{os.path.splitext(file_path)[0]}.png"
        subprocess.run(['pdftoppm', file_path, os.path.splitext(file_path)[0], '-png', '-f', '1', '-singlefile'])
        if os.path.isfile(image_file):
            ocr_text = subprocess.check_output(['tesseract', image_file, 'stdout', '-l', self.config['LANGUAGE']]).decode('utf-8')
            os.remove(image_file)
            return ocr_text
        return ""

    def perform_image_ocr(self, file_path: str) -> str:
        return subprocess.check_output(['tesseract', file_path, 'stdout', '-l', self.config['LANGUAGE']]).decode('utf-8')

    def call_llm(self, prompt: str) -> str:
        try:
            response = requests.post(
                'http://localhost:11434/api/generate',
                json={"model": "llama2", "stream": False, "prompt": prompt, "max_tokens": 100},
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
            return response_data.get('response', '').strip()
        except requests.RequestException as e:
            handle_exception("LLM API call", e)
            return ''
        except json.JSONDecodeError as e:
            handle_exception("LLM response parsing", e)
            return ''

    def rename_pdf(self, file_path: str, file_name: str, done_dir: str, orig_dir: str) -> None:
        ocr_text = self.perform_ocr(file_path)
        if not ocr_text:
            logging.warning(f"OCR failed for file: {file_path}")
            return

        ai_generated_filename = self.generate_filename(ocr_text)
        if not ai_generated_filename:
            logging.warning(f"Failed to generate filename for: {file_path}")
            return

        cleaned_filename = self.clean_filename(ai_generated_filename)
        if not cleaned_filename:
            logging.warning(f"Generated filename is invalid for: {file_path}")
            return

        new_filename = f"{cleaned_filename}.pdf"
        new_filepath = os.path.join(done_dir, new_filename)

        try:
            self.move_or_copy_file(file_path, new_filepath, orig_dir, file_name)
        except OSError as e:
            logging.error(f"Error renaming file {file_path}: {str(e)}")

    def generate_filename(self, ocr_text: str) -> str:
        filename_prompt = self.config['prompts']['filename_generation']
        payload = {
            "messages": [
                {"role": "system", "content": filename_prompt},
                {"role": "user", "content": f"Here is the file content: {ocr_text}"}
            ],
            "temperature": 0,
            "max_tokens": 100,
            "stream": False
        }

        try:
            response = requests.post(
                'http://localhost:11434/v1/chat/completions',
                headers={"Content-Type": "application/json"},
                data=json.dumps(payload),
                timeout=30
            )
            response.raise_for_status()
            response_json = response.json()
            return response_json['choices'][0]['message']['content'].strip()
        except (requests.RequestException, json.JSONDecodeError, KeyError) as e:
            logging.error(f"Error generating filename: {str(e)}")
            return ''

    def clean_filename(self, filename: str) -> str:
        cleaned_content = re.sub(r'[^a-zA-Z0-9 ]', ' ', filename)
        cleaned_content = re.sub(r'\s+', ' ', cleaned_content).strip()
        cleaned_content = re.sub(r'([a-z])([A-Z])', r'\1 \2', cleaned_content)
        content_length = len(cleaned_content)

        if 15 <= content_length <= 100:
            return cleaned_content
        return ''

    def move_or_copy_file(self, file_path: str, new_filepath: str, orig_dir: str, file_name: str) -> None:
        try:
            if self.args.move:
                shutil.move(file_path, new_filepath)
                logging.info(f"'{file_path}' was successfully renamed to '{new_filepath}' and moved")
            elif self.args.keep_original:
                shutil.copy2(file_path, new_filepath)
                shutil.move(file_path, os.path.join(orig_dir, file_name))
                logging.info(f"'{file_path}' was successfully renamed to '{new_filepath}' and copied")
            else:
                os.rename(file_path, new_filepath)
                logging.info(f"'{file_path}' was successfully renamed to '{new_filepath}'")
        except (IOError, OSError) as e:
            handle_exception("file operation", e)

def setup_logging(debug: bool) -> None:
    level = logging.DEBUG if debug else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('file_processor.log')
        ]
    )

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Process files in a directory using OCR and AI to generate filenames.')
    parser.add_argument('directory', type=str, help='The directory containing files to process.')
    parser.add_argument('-r', '--rename', action='store_true', help='Trigger the rename function.')
    parser.add_argument('-s', '--summarize', action='store_true', help='Enable summarization of the OCR text.')
    parser.add_argument('-m', '--move', action='store_true', help='Move the files after processing.')
    parser.add_argument('-o', '--keep-ocr-output', action='store_true', help='Keep a copy of the OCR output per file in the same directory.')
    parser.add_argument('-d', '--debug', action='store_true', help='Enable debug logging.')
    parser.add_argument('--keep-original', type=bool, default=True, help='Preserve the original file after renaming. Default is True.')
    return parser.parse_args()

def read_config() -> Dict[str, Any]:
    config_file = 'config.json'
    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except FileNotFoundError as e:
        handle_exception("config file reading", e)
        return {}
    except json.JSONDecodeError as e:
        handle_exception("config file parsing", e)
        return {}

def write_config(config: Dict[str, Any]) -> None:
    config_file = 'config.json'
    try:
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=4)
    except IOError as e:
        handle_exception("config file writing", e)

def create_config() -> Dict[str, Any]:
    LANGUAGE = input(f"Enter the language for OCR (default: eng): ") or 'eng'
    ORIG_SUBDIR = input(f"Enter the original subdirectory (default: orig): ") or 'orig'
    return {'LANGUAGE': LANGUAGE, 'ORIG_SUBDIR': ORIG_SUBDIR}

def main():
    args = parse_arguments()
    setup_logging(args.debug)

    # Log script start
    logging.info("File processing script started")

    # Log configuration details
    logging.info(f"Processing directory: {args.directory}")
    logging.info(f"Rename mode: {'Enabled' if args.rename else 'Disabled'}")
    logging.info(f"Summarize mode: {'Enabled' if args.summarize else 'Disabled'}")
    logging.info(f"Move files: {'Yes' if args.move else 'No'}")
    logging.info(f"Keep original: {'Yes' if args.keep_original else 'No'}")
    logging.info(f"Debug mode: {'Enabled' if args.debug else 'Disabled'}")

    config = read_config()
    if not config:
        config = create_config()
        write_config(config)

    processor = FileProcessor(config, args)

    if not os.path.isdir(args.directory):
        create_dir = input(f"The directory '{args.directory}' does not exist. Do you want to create it? (y/n): ")
        if create_dir.lower() == 'y':
            processor.create_directory(args.directory)
        else:
            logging.error(f"The directory '{args.directory}' does not exist.")
            sys.exit(1)

    processor.process_files(args.directory)

if __name__ == '__main__':
    main()
